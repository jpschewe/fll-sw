{"version":3,"sources":["webpack://JSJodaExtra/webpack/universalModuleDefinition","webpack://JSJodaExtra/webpack/bootstrap","webpack://JSJodaExtra/./src/Interval.js","webpack://JSJodaExtra/./src/_init.js","webpack://JSJodaExtra/./src/assert.js","webpack://JSJodaExtra/./src/js-joda-extra.js","webpack://JSJodaExtra/./src/plug.js","webpack://JSJodaExtra/external {\"amd\":\"@js-joda/core\",\"commonjs\":\"@js-joda/core\",\"commonjs2\":\"@js-joda/core\",\"root\":\"JSJoda\"}"],"names":["Interval","of","startInstant","endInstantOrDuration","Duration","ofInstantDuration","ofInstantInstant","startInclusive","endExclusive","requireNonNull","requireInstance","Instant","isBefore","DateTimeException","duration","isNegative","plus","parse","text","IllegalArgumentException","constructor","name","i","length","charAt","firstChar","substring","end","ZonedDateTime","toInstant","minus","start","c","DateTimeParseException","_start","_end","isEmpty","equals","isUnboundedStart","MIN","isUnboundedEnd","MAX","withStart","withEnd","contains","instant","compareTo","encloses","other","abuts","isConnected","overlaps","intersection","cmpStart","cmpEnd","newStart","newEnd","union","span","isAfter","instantOrInterval","isAfterInstant","isAfterInterval","isBeforeInstant","isBeforeInterval","interval","toDuration","between","obj","hashCode","toString","_init","ALL","isInit","init","intervalInit","assert","assertion","msg","error","Error","value","parameterName","NullPointerException","_class","abstractMethodFail","methodName","TypeError","use","plug"],"mappings":"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","file":"js-joda-extra.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@js-joda/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@js-joda/core\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JSJodaExtra\"] = factory(require(\"@js-joda/core\"));\n\telse\n\t\troot[\"JSJodaExtra\"] = factory(root[\"JSJoda\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__js_joda_core__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js-joda-extra.js\");\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/* eslint-disable no-else-return */\nimport { DateTimeException, DateTimeParseException, Duration, IllegalArgumentException, Instant, ZonedDateTime } from '@js-joda/core';\n\n// TODO: hm... is this a good idea?? copied from joda currently, could we add a js-joda-utils module??\nimport { requireNonNull, requireInstance } from './assert';\n\n/**\n * An immutable interval of time between two instants.\n * <p>\n * An interval represents the time on the time-line between two {@link Instant}s.\n * The class stores the start and end instants, with the start inclusive and the end exclusive.\n * The end instant is always greater than or equal to the start instant.\n * <p>\n * The {@link Duration} of an interval can be obtained, but is a separate concept.\n * An interval is connected to the time-line, whereas a duration is not.\n * <p>\n * Intervals are not comparable. To compare the length of two intervals, it is\n * generally recommended to compare their durations.\n *\n */\nexport class Interval {\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link Interval.of}\n     *\n     * if called without arguments, then {@link Interval.ofInstantInstant} is executed.\n\n     * if called with 1 arguments and first argument is an instance of ZoneId, then {@link Interval.ofInstantDuration} is executed.\n     *\n     * Otherwise {@link Interval.ofInstantDuration} is executed.\n     *\n     * @param {!(Instant)} startInstant\n     * @param {!(Instant|Duration)} endInstantOrDuration\n     * @returns {Interval}\n     */\n    static of(startInstant, endInstantOrDuration) {\n        if (endInstantOrDuration instanceof Duration) {\n            return Interval.ofInstantDuration(startInstant, endInstantOrDuration);\n        } else {\n            return Interval.ofInstantInstant(startInstant, endInstantOrDuration);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@code Interval} from the start and end instant.\n     * <p>\n     * The end instant must not be before the start instant.\n     *\n     * @param {Instant} startInclusive  the start instant, inclusive, MIN_DATE treated as unbounded, not null\n     * @param {Instant} endExclusive  the end instant, exclusive, MAX_DATE treated as unbounded, not null\n     * @return {Interval} the half-open interval, not null\n     * @throws DateTimeException if the end is before the start\n     */\n    static ofInstantInstant(startInclusive, endExclusive) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(endExclusive, 'endExclusive');\n        requireInstance(startInclusive, Instant, 'startInclusive');\n        requireInstance(endExclusive, Instant, 'endExclusive');\n        if (endExclusive.isBefore(startInclusive)) {\n            throw new DateTimeException('End instant must on or after start instant');\n        }\n        return new Interval(startInclusive, endExclusive);\n    }\n\n    /**\n     * Obtains an instance of {@code Interval} from the start and a duration.\n     * <p>\n     * The end instant is calculated as the start plus the duration.\n     * The duration must not be negative.\n     *\n     * @param {Instant} startInclusive  the start instant, inclusive, not null\n     * @param {Duration} duration  the duration from the start to the end, not null\n     * @return {Interval} the interval, not null\n     * @throws DateTimeException if the end is before the start,\n     *  or if the duration addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs when adding the duration\n     */\n    static ofInstantDuration(startInclusive, duration) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(duration, 'duration');\n        requireInstance(startInclusive, Instant, 'startInclusive');\n        requireInstance(duration, Duration, 'duration');\n        if (duration.isNegative()) {\n            throw new DateTimeException('Duration must not be zero or negative');\n        }\n        return new Interval(startInclusive, startInclusive.plus(duration));\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Obtains an instance of {@code Interval} from a text string such as\n     * {@code 2007-12-03T10:15:30Z/2007-12-04T10:15:30Z}, where the end instant is exclusive.\n     * <p>\n     * The string must consist of one of the following three formats:\n     * <ul>\n     * <li>a representations of an {@link ZonedDateTime}, followed by a forward slash,\n     *  followed by a representation of a {@link ZonedDateTime}\n     * <li>a representation of an {@link ZonedDateTime}, followed by a forward slash,\n     *  followed by a representation of a {@link Duration}\n     * <li>a representation of a {@link Duration}, followed by a forward slash,\n     *  followed by a representation of an {@link ZonedDateTime}\n     * </ul>\n     *\n     * NOTE: in contrast to the threeten-extra base we are not using `OffsetDateTime` but `ZonedDateTime` to parse\n     * the string, this does not change the format but adds the possibility to optionally specify a zone\n     *\n     * @param {string} text  the text to parse, not null\n     * @return {Interval} the parsed interval, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parse(text) {\n        requireNonNull(text, 'text');\n        if (!(typeof text === 'string')) {\n            throw new IllegalArgumentException(`text must be a string, but is ${text.constructor.name}`);\n        }\n        for (let i = 0; i < text.length; i += 1) {\n            if (text.charAt(i) === '/') {\n                const firstChar = text.charAt(0);\n                if (firstChar === 'P' || firstChar === 'p') {\n                    // duration followed by instant\n                    const duration = Duration.parse(text.substring(0, i));\n                    const end = ZonedDateTime.parse(text.substring(i + 1, text.length)).toInstant();\n                    return Interval.of(end.minus(duration), end);\n                } else {\n                    // instant followed by instant or duration\n                    const start = ZonedDateTime.parse(text.substring(0, i)).toInstant();\n                    if (i + 1 < text.length) {\n                        const c = text.charAt(i + 1);\n                        if (c === 'P' || c === 'p') {\n                            const duration = Duration.parse(text.substring(i + 1, text.length));\n                            return Interval.of(start, start.plus(duration));\n                        }\n                    }\n                    const end = ZonedDateTime.parse(text.substring(i + 1, text.length)).toInstant();\n                    return Interval.of(start, end);\n                }\n            }\n        }\n        throw new DateTimeParseException('Interval cannot be parsed, no forward slash found', text, 0);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {Instant} startInclusive  the start instant, inclusive, validated not null\n     * @param {Instant} endExclusive  the end instant, exclusive, validated not null\n     */\n    constructor(startInclusive, endExclusive) {\n        this._start = startInclusive;\n        this._end = endExclusive;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the start of this time interval, inclusive.\n     * <p>\n     * This will return {@link Instant#MIN} if the range is unbounded at the start.\n     * In this case, the range includes all dates into the far-past.\n     *\n     * @return {Instant} the start of the time interval\n     */\n    start() {\n        return this._start;\n    }\n\n    /**\n     * Gets the end of this time interval, exclusive.\n     * <p>\n     * This will return {@link Instant#MAX} if the range is unbounded at the end.\n     * In this case, the range includes all dates into the far-future.\n     *\n     * @return {Instant} the end of the time interval, exclusive\n     */\n    end() {\n        return this._end;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the range is empty.\n     * <p>\n     * An empty range occurs when the start date equals the inclusive end date.\n     *\n     * @return {boolean} true if the range is empty\n     */\n    isEmpty() {\n        return this._start.equals(this._end);\n    }\n\n    /**\n     * Checks if the start of the interval is unbounded.\n     *\n     * @return {boolean} true if start is unbounded\n     */\n    isUnboundedStart() {\n        return this._start.equals(Instant.MIN);\n    }\n\n    /**\n     * Checks if the end of the interval is unbounded.\n     *\n     * @return {boolean} true if end is unbounded\n     */\n    isUnboundedEnd() {\n        return this._end.equals(Instant.MAX);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this range with the specified start instant.\n     *\n     * @param {Instant} start  the start instant for the new interval, not null\n     * @return {Interval} an interval with the end from this interval and the specified start\n     * @throws DateTimeException if the resulting interval has end before start\n     */\n    withStart(start) {\n        return Interval.of(start, this._end);\n    }\n\n    /**\n     * Returns a copy of this range with the specified end instant.\n     *\n     * @param {Instant} end  the end instant for the new interval, not null\n     * @return {Interval} an interval with the start from this interval and the specified end\n     * @throws DateTimeException if the resulting interval has end before start\n     */\n    withEnd(end) {\n        return Interval.of(this._start, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this interval contains the specified instant.\n     * <p>\n     * This checks if the specified instant is within the bounds of this interval.\n     * If this range has an unbounded start then {@code contains(Instant#MIN)} returns true.\n     * If this range has an unbounded end then {@code contains(Instant#MAX)} returns true.\n     * If this range is empty then this method always returns false.\n     *\n     * @param {Instant} instant  the instant, not null\n     * @return {boolean} true if this interval contains the instant\n     */\n    contains(instant) {\n        requireNonNull(instant, 'instant');\n        requireInstance(instant, Instant, 'instant');\n        return this._start.compareTo(instant) <= 0 && (instant.compareTo(this._end) < 0 || this.isUnboundedEnd());\n    }\n\n    /**\n     * Checks if this interval encloses the specified interval.\n     * <p>\n     * This checks if the bounds of the specified interval are within the bounds of this interval.\n     * An empty interval encloses itself.\n     *\n     * @param {Interval} other  the other interval, not null\n     * @return {boolean} true if this interval contains the other interval\n     */\n    encloses(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        return this._start.compareTo(other.start()) <= 0 && other.end().compareTo(this._end) <= 0;\n    }\n\n    /**\n     * Checks if this interval abuts the specified interval.\n     * <p>\n     * The result is true if the end of this interval is the start of the other, or vice versa.\n     * An empty interval does not abut itself.\n     *\n     * @param {Interval} other  the other interval, not null\n     * @return {boolean} true if this interval abuts the other interval\n     */\n    abuts(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        return !this._end.equals(other.start()) !== !this._start.equals(other.end());\n    }\n\n    /**\n     * Checks if this interval is connected to the specified interval.\n     * <p>\n     * The result is true if the two intervals have an enclosed interval in common, even if that interval is empty.\n     * An empty interval is connected to itself.\n     * <p>\n     * This is equivalent to {@code (overlaps(other) || abuts(other))}.\n     *\n     * @param {Interval} other  the other interval, not null\n     * @return {boolean} true if this interval is connected to the other interval\n     */\n    isConnected(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        return this.equals(other) || (this._start.compareTo(other.end()) <= 0 && other.start().compareTo(this._end) <= 0);\n    }\n\n    /**\n     * Checks if this interval overlaps the specified interval.\n     * <p>\n     * The result is true if the the two intervals share some part of the time-line.\n     * An empty interval overlaps itself.\n     * <p>\n     * This is equivalent to {@code (isConnected(other) && !abuts(other))}.\n     *\n     * @param {Interval} other  the time interval to compare to, null means a zero length interval now\n     * @return {boolean} true if the time intervals overlap\n     */\n    overlaps(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        return other.equals(this) || (this._start.compareTo(other.end()) < 0 && other.start().compareTo(this._end) < 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the interval that is the intersection of this interval and the specified interval.\n     * <p>\n     * This finds the intersection of two intervals.\n     * This throws an exception if the two intervals are not {@linkplain #isConnected(Interval) connected}.\n     *\n     * @param {Interval} other  the other interval to check for, not null\n     * @return {Interval} the interval that is the intersection of the two intervals\n     * @throws DateTimeException if the intervals do not connect\n     */\n    intersection(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        if (this.isConnected(other) === false) {\n            throw new DateTimeException(`Intervals do not connect: ${this} and ${other}`);\n        }\n        const cmpStart = this._start.compareTo(other.start());\n        const cmpEnd = this._end.compareTo(other.end());\n        if (cmpStart >= 0 && cmpEnd <= 0) {\n            return this;\n        } else if (cmpStart <= 0 && cmpEnd >= 0) {\n            return other;\n        } else {\n            const newStart = (cmpStart >= 0 ? this._start : other.start());\n            const newEnd = (cmpEnd <= 0 ? this._end : other.end());\n            return Interval.of(newStart, newEnd);\n        }\n    }\n\n    /**\n     * Calculates the interval that is the union of this interval and the specified interval.\n     * <p>\n     * This finds the union of two intervals.\n     * This throws an exception if the two intervals are not {@linkplain #isConnected(Interval) connected}.\n     *\n     * @param {Interval} other  the other interval to check for, not null\n     * @return {Interval} the interval that is the union of the two intervals\n     * @throws DateTimeException if the intervals do not connect\n     */\n    union(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        if (this.isConnected(other) === false) {\n            throw new DateTimeException(`Intervals do not connect: ${this} and ${other}`);\n        }\n        const cmpStart = this._start.compareTo(other.start());\n        const cmpEnd = this._end.compareTo(other.end());\n        if (cmpStart >= 0 && cmpEnd <= 0) {\n            return other;\n        } else if (cmpStart <= 0 && cmpEnd >= 0) {\n            return this;\n        } else {\n            const newStart = (cmpStart >= 0 ? other.start() : this._start);\n            const newEnd = (cmpEnd <= 0 ? other.end() : this._end);\n            return Interval.of(newStart, newEnd);\n        }\n    }\n\n    /**\n     * Calculates the smallest interval that encloses this interval and the specified interval.\n     * <p>\n     * The result of this method will {@linkplain #encloses(Interval) enclose}\n     * this interval and the specified interval.\n     *\n     * @param {Interval} other  the other interval to check for, not null\n     * @return {Interval} the interval that spans the two intervals\n     */\n    span(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        const cmpStart = this._start.compareTo(other.start());\n        const cmpEnd = this._end.compareTo(other.end());\n        const newStart = (cmpStart >= 0 ? other.start() : this._start);\n        const newEnd = (cmpEnd <= 0 ? other.end() : this._end);\n        return Interval.of(newStart, newEnd);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * function overloading for {@link Interval#isAfter}\n     *\n     * if called with an Instant, then {@link Interval#isAfterInstant} is executed.\n     *\n     * Otherwise {@link Interval#isAfterInterval} is executed.\n     *\n     * @param {!(Instant|Interval)} instantOrInterval\n     * @returns {boolean}\n     */\n    isAfter(instantOrInterval) {\n        if (instantOrInterval instanceof Instant) {\n            return this.isAfterInstant(instantOrInterval);\n        } else {\n            return this.isAfterInterval(instantOrInterval);\n        }\n    }\n\n    /**\n     * function overloading for {@link Interval#isBefore}\n     *\n     * if called with an Instant, then {@link Interval#isBeforeInstant} is executed.\n     *\n     * Otherwise {@link Interval#isBeforeInterval} is executed.\n     *\n     * @param {!(Instant|Interval)} instantOrInterval\n     * @returns {boolean}\n     */\n    isBefore(instantOrInterval) {\n        if (instantOrInterval instanceof Instant) {\n            return this.isBeforeInstant(instantOrInterval);\n        } else {\n            return this.isBeforeInterval(instantOrInterval);\n        }\n    }\n\n    /**\n     * Checks if this interval is after the specified instant.\n     * <p>\n     * The result is true if the this instant starts after the specified instant.\n     * An empty interval behaves as though it is an instant for comparison purposes.\n     *\n     * @param {Instant} instant  the other instant to compare to, not null\n     * @return {boolean} true if the start of this interval is after the specified instant\n     */\n    isAfterInstant(instant) {\n        return this._start.compareTo(instant) > 0;\n    }\n\n    /**\n     * Checks if this interval is before the specified instant.\n     * <p>\n     * The result is true if the this instant ends before the specified instant.\n     * Since intervals do not include their end points, this will return true if the\n     * instant equals the end of the interval.\n     * An empty interval behaves as though it is an instant for comparison purposes.\n     *\n     * @param {Instant} instant  the other instant to compare to, not null\n     * @return {boolean} true if the start of this interval is before the specified instant\n     */\n    isBeforeInstant(instant) {\n        return this._end.compareTo(instant) <= 0 && this._start.compareTo(instant) < 0;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Checks if this interval is after the specified interval.\n     * <p>\n     * The result is true if the this instant starts after the end of the specified interval.\n     * Since intervals do not include their end points, this will return true if the\n     * instant equals the end of the interval.\n     * An empty interval behaves as though it is an instant for comparison purposes.\n     *\n     * @param {Interval} interval  the other interval to compare to, not null\n     * @return {boolean} true if this instant is after the specified instant\n     */\n    isAfterInterval(interval) {\n        return this._start.compareTo(interval.end()) >= 0 && !interval.equals(this);\n    }\n\n    /**\n     * Checks if this interval is before the specified interval.\n     * <p>\n     * The result is true if the this instant ends before the start of the specified interval.\n     * Since intervals do not include their end points, this will return true if the\n     * two intervals abut.\n     * An empty interval behaves as though it is an instant for comparison purposes.\n     *\n     * @param {Interval} interval  the other interval to compare to, not null\n     * @return {boolean} true if this instant is before the specified instant\n     */\n    isBeforeInterval(interval) {\n        return this._end.compareTo(interval.start()) <= 0 && !interval.equals(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the duration of this interval.\n     * <p>\n     * An {@code Interval} is associated with two specific instants on the time-line.\n     * A {@code Duration} is simply an amount of time, separate from the time-line.\n     *\n     * @return {Duration} the duration of the time interval\n     * @throws ArithmeticException if the calculation exceeds the capacity of {@code Duration}\n     */\n    toDuration() {\n        return Duration.between(this._start, this._end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this interval is equal to another interval.\n     * <p>\n     * Compares this {@code Interval} with another ensuring that the two instants are the same.\n     * Only objects of type {@code Interval} are compared, other types return false.\n     *\n     * @param {*} obj  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other interval\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof Interval) {\n            return this._start.equals(obj.start()) && this._end.equals(obj.end());\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this interval.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        // eslint-disable-next-line no-bitwise\n        return this._start.hashCode() ^ this._end.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this interval as a {@code String}, such as {@code 2007-12-03T10:15:30/2007-12-04T10:15:30}.\n     * <p>\n     * The output will be the ISO-8601 format formed by combining the\n     * {@code toString()} methods of the two instants, separated by a forward slash.\n     *\n     * @return {string} a string representation of this instant, not null\n     */\n    toString() {\n        return `${this._start.toString()}/${this._end.toString()}`;\n    }\n}\n\nexport function _init() {\n    Interval.ALL = Interval.of(Instant.MIN, Instant.MAX);\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { _init as intervalInit } from './Interval';\n\nlet isInit = false;\n\nfunction init() {\n    if (isInit) {\n        return;\n    }\n\n    isInit = true;\n\n    intervalInit();\n}\n\ninit();\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport { NullPointerException, IllegalArgumentException } from '@js-joda/core';\n\nexport function assert(assertion, msg, error) {\n    if (!assertion) {\n        if (error) {\n            // eslint-disable-next-line new-cap\n            throw new error(msg);\n        } else {\n            throw new Error(msg);\n        }\n    }\n}\n\nexport function requireNonNull(value, parameterName) {\n    if (value == null) {\n        throw new NullPointerException(`${parameterName} must not be null`);\n    }\n    return value;\n}\n\nexport function requireInstance(value, _class, parameterName) {\n    if (!(value instanceof _class)) {\n        throw new IllegalArgumentException(`${parameterName} must be an instance of ${_class.name ? _class.name : _class}${value && value.constructor && value.constructor.name ? `, but is ${value.constructor.name}` : ''}`);\n    }\n    return value;\n}\n\nexport function abstractMethodFail(methodName) {\n    throw new TypeError(`abstract method \"${methodName}\" is not implemented`);\n}\n","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport { use } from '@js-joda/core';\n\nimport { Interval } from './Interval';\nimport plug from './plug';\n\nuse(plug);\n\nexport {\n    Interval,\n};\n","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\n// import { Interval } from './Interval';\n\nimport './_init';\n\n/**\n * plugin Function, call using js-jodas use()\n *\n * @param jsJoda\n */\nexport default function (/* jsJoda */) {\n    // assign new prop to jsJoda context is useless, because it lives only in the local context\n    // jsJoda.Interval = Interval;\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__js_joda_core__;"],"sourceRoot":""}