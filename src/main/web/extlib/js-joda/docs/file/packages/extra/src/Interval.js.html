<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">packages/extra/src/Interval.js | js-joda</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Immutable date and time library for JavaScript"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="js-joda"><meta property="twitter:description" content="Immutable date and time library for JavaScript"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/js-joda/js-joda"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-src">core/src</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/Clock.js~Clock.html">Clock</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/DayOfWeek.js~DayOfWeek.html">DayOfWeek</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/Duration.js~Duration.html">Duration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/Enum.js~Enum.html">Enum</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/Instant.js~Instant.html">Instant</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/LocalDate.js~LocalDate.html">LocalDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/LocalDateTime.js~LocalDateTime.html">LocalDateTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/LocalTime.js~LocalTime.html">LocalTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/MathUtil.js~MathUtil.html">MathUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/Month.js~Month.html">Month</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/MonthDay.js~MonthDay.html">MonthDay</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/Period.js~Period.html">Period</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/Year.js~Year.html">Year</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/YearConstants.js~YearConstants.html">YearConstants</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/YearMonth.js~YearMonth.html">YearMonth</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/ZoneId.js~ZoneId.html">ZoneId</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/ZoneOffset.js~ZoneOffset.html">ZoneOffset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/ZoneRegion.js~ZoneRegion.html">ZoneRegion</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/ZonedDateTime.js~ZonedDateTime.html">ZonedDateTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-abstractMethodFail">abstractMethodFail</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-assert">assert</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-requireInstance">requireInstance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-requireNonNull">requireNonNull</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-convert">convert</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-bindUse">bindUse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-MAX_SAFE_INTEGER">MAX_SAFE_INTEGER</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-MIN_SAFE_INTEGER">MIN_SAFE_INTEGER</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ArithmeticException">ArithmeticException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DateTimeException">DateTimeException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DateTimeParseException">DateTimeParseException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IllegalArgumentException">IllegalArgumentException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IllegalStateException">IllegalStateException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NullPointerException">NullPointerException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UnsupportedTemporalTypeException">UnsupportedTemporalTypeException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-use">use</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-src-chrono">core/src/chrono</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/chrono/ChronoLocalDate.js~ChronoLocalDate.html">ChronoLocalDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime.html">ChronoLocalDateTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime.html">ChronoZonedDateTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/chrono/IsoChronology.js~IsoChronology.html">IsoChronology</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-src-format">core/src/format</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter.html">DateTimeFormatter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder.html">DateTimeFormatterBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/format/DecimalStyle.js~DecimalStyle.html">DecimalStyle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/format/ResolverStyle.js~ResolverStyle.html">ResolverStyle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/format/SignStyle.js~SignStyle.html">SignStyle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/format/TextStyle.js~TextStyle.html">TextStyle</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-src-temporal">core/src/temporal</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/ChronoField.js~ChronoField.html">ChronoField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/ChronoUnit.js~ChronoUnit.html">ChronoUnit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/DefaultInterfaceTemporal.js~DefaultInterfaceTemporal.html">DefaultInterfaceTemporal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/IsoFields.js~IsoFields.html">IsoFields</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor.html">TemporalAccessor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.html">TemporalAdjusters</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/TemporalQueries.js~TemporalQueries.html">TemporalQueries</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/ValueRange.js~ValueRange.html">ValueRange</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/Temporal.js~Temporal.html">Temporal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/TemporalAdjuster.js~TemporalAdjuster.html">TemporalAdjuster</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/TemporalAmount.js~TemporalAmount.html">TemporalAmount</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/TemporalField.js~TemporalField.html">TemporalField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/TemporalQuery.js~TemporalQuery.html">TemporalQuery</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/packages/core/src/temporal/TemporalUnit.js~TemporalUnit.html">TemporalUnit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-nativeJs">nativeJs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createTemporalQuery">createTemporalQuery</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-src-zone">core/src/zone</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/zone/SystemDefaultZoneId.js~SystemDefaultZoneId.html">SystemDefaultZoneId</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules.html">SystemDefaultZoneRules</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition.html">ZoneOffsetTransition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/zone/ZoneRules.js~ZoneRules.html">ZoneRules</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/core/src/zone/ZoneRulesProvider.js~ZoneRulesProvider.html">ZoneRulesProvider</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#extra-src">extra/src</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/extra/src/Interval.js~Interval.html">Interval</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-abstractMethodFail">abstractMethodFail</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-assert">assert</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-requireInstance">requireInstance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-requireNonNull">requireNonNull</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-plug">plug</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#locale-src">locale/src</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/locale/src/Locale.js~Locale.html">Locale</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-plug">plug</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#locale-src-format">locale/src/format</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/locale/src/format/LocaleDateTimeFormatter.js~LocaleDateTimeFormatter.html">LocaleDateTimeFormatter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/locale/src/format/LocaleStore.js~LocaleStore.html">LocaleStore</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createEntry">createEntry</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#locale-src-format-cldr">locale/src/format/cldr</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/locale/src/format/cldr/CldrDateTimeFormatterBuilder.js~CldrDateTimeFormatterBuilder.html">CldrDateTimeFormatterBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser.html">CldrZoneTextPrinterParser</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#locale-src-format-parser">locale/src/format/parser</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser.html">WeekFieldsPrinterParser</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#locale-src-temporal">locale/src/temporal</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/locale/src/temporal/WeekFields.js~ComputedDayOfField.html">ComputedDayOfField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/locale/src/temporal/WeekFields.js~WeekFields.html">WeekFields</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#timezone-src">timezone/src</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/timezone/src/MomentZoneRules.js~MomentZoneRules.html">MomentZoneRules</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/timezone/src/MomentZoneRulesProvider.js~MomentZoneRulesProvider.html">MomentZoneRulesProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-autoPlug">autoPlug</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-plug">plug</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-extendSystemDefaultZoneId">extendSystemDefaultZoneId</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack">unpack</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">packages/extra/src/Interval.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*
 * @copyright (c) 2016, Philipp Th&#xFC;rw&#xE4;chter &amp; Pattrick H&#xFC;per
 * @copyright (c) 2007-present, Stephen Colebourne &amp; Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

/* eslint-disable no-else-return */
import { DateTimeException, DateTimeParseException, Duration, IllegalArgumentException, Instant, ZonedDateTime } from &apos;@js-joda/core&apos;;

// TODO: hm... is this a good idea?? copied from joda currently, could we add a js-joda-utils module??
import { requireNonNull, requireInstance } from &apos;./assert&apos;;

/**
 * An immutable interval of time between two instants.
 * &lt;p&gt;
 * An interval represents the time on the time-line between two {@link Instant}s.
 * The class stores the start and end instants, with the start inclusive and the end exclusive.
 * The end instant is always greater than or equal to the start instant.
 * &lt;p&gt;
 * The {@link Duration} of an interval can be obtained, but is a separate concept.
 * An interval is connected to the time-line, whereas a duration is not.
 * &lt;p&gt;
 * Intervals are not comparable. To compare the length of two intervals, it is
 * generally recommended to compare their durations.
 *
 */
export class Interval {
    //-----------------------------------------------------------------------
    /**
     * function overloading for {@link Interval.of}
     *
     * if called without arguments, then {@link Interval.ofInstantInstant} is executed.

     * if called with 1 arguments and first argument is an instance of ZoneId, then {@link Interval.ofInstantDuration} is executed.
     *
     * Otherwise {@link Interval.ofInstantDuration} is executed.
     *
     * @param {!(Instant)} startInstant
     * @param {!(Instant|Duration)} endInstantOrDuration
     * @returns {Interval}
     */
    static of(startInstant, endInstantOrDuration) {
        if (endInstantOrDuration instanceof Duration) {
            return Interval.ofInstantDuration(startInstant, endInstantOrDuration);
        } else {
            return Interval.ofInstantInstant(startInstant, endInstantOrDuration);
        }
    }

    /**
     * Obtains an instance of {@code Interval} from the start and end instant.
     * &lt;p&gt;
     * The end instant must not be before the start instant.
     *
     * @param {Instant} startInclusive  the start instant, inclusive, MIN_DATE treated as unbounded, not null
     * @param {Instant} endExclusive  the end instant, exclusive, MAX_DATE treated as unbounded, not null
     * @return {Interval} the half-open interval, not null
     * @throws DateTimeException if the end is before the start
     */
    static ofInstantInstant(startInclusive, endExclusive) {
        requireNonNull(startInclusive, &apos;startInclusive&apos;);
        requireNonNull(endExclusive, &apos;endExclusive&apos;);
        requireInstance(startInclusive, Instant, &apos;startInclusive&apos;);
        requireInstance(endExclusive, Instant, &apos;endExclusive&apos;);
        if (endExclusive.isBefore(startInclusive)) {
            throw new DateTimeException(&apos;End instant must on or after start instant&apos;);
        }
        return new Interval(startInclusive, endExclusive);
    }

    /**
     * Obtains an instance of {@code Interval} from the start and a duration.
     * &lt;p&gt;
     * The end instant is calculated as the start plus the duration.
     * The duration must not be negative.
     *
     * @param {Instant} startInclusive  the start instant, inclusive, not null
     * @param {Duration} duration  the duration from the start to the end, not null
     * @return {Interval} the interval, not null
     * @throws DateTimeException if the end is before the start,
     *  or if the duration addition cannot be made
     * @throws ArithmeticException if numeric overflow occurs when adding the duration
     */
    static ofInstantDuration(startInclusive, duration) {
        requireNonNull(startInclusive, &apos;startInclusive&apos;);
        requireNonNull(duration, &apos;duration&apos;);
        requireInstance(startInclusive, Instant, &apos;startInclusive&apos;);
        requireInstance(duration, Duration, &apos;duration&apos;);
        if (duration.isNegative()) {
            throw new DateTimeException(&apos;Duration must not be zero or negative&apos;);
        }
        return new Interval(startInclusive, startInclusive.plus(duration));
    }

    //-----------------------------------------------------------------------

    /**
     * Obtains an instance of {@code Interval} from a text string such as
     * {@code 2007-12-03T10:15:30Z/2007-12-04T10:15:30Z}, where the end instant is exclusive.
     * &lt;p&gt;
     * The string must consist of one of the following three formats:
     * &lt;ul&gt;
     * &lt;li&gt;a representations of an {@link ZonedDateTime}, followed by a forward slash,
     *  followed by a representation of a {@link ZonedDateTime}
     * &lt;li&gt;a representation of an {@link ZonedDateTime}, followed by a forward slash,
     *  followed by a representation of a {@link Duration}
     * &lt;li&gt;a representation of a {@link Duration}, followed by a forward slash,
     *  followed by a representation of an {@link ZonedDateTime}
     * &lt;/ul&gt;
     *
     * NOTE: in contrast to the threeten-extra base we are not using `OffsetDateTime` but `ZonedDateTime` to parse
     * the string, this does not change the format but adds the possibility to optionally specify a zone
     *
     * @param {string} text  the text to parse, not null
     * @return {Interval} the parsed interval, not null
     * @throws DateTimeParseException if the text cannot be parsed
     */
    static parse(text) {
        requireNonNull(text, &apos;text&apos;);
        if (!(typeof text === &apos;string&apos;)) {
            throw new IllegalArgumentException(`text must be a string, but is ${text.constructor.name}`);
        }
        for (let i = 0; i &lt; text.length; i += 1) {
            if (text.charAt(i) === &apos;/&apos;) {
                const firstChar = text.charAt(0);
                if (firstChar === &apos;P&apos; || firstChar === &apos;p&apos;) {
                    // duration followed by instant
                    const duration = Duration.parse(text.substring(0, i));
                    const end = ZonedDateTime.parse(text.substring(i + 1, text.length)).toInstant();
                    return Interval.of(end.minus(duration), end);
                } else {
                    // instant followed by instant or duration
                    const start = ZonedDateTime.parse(text.substring(0, i)).toInstant();
                    if (i + 1 &lt; text.length) {
                        const c = text.charAt(i + 1);
                        if (c === &apos;P&apos; || c === &apos;p&apos;) {
                            const duration = Duration.parse(text.substring(i + 1, text.length));
                            return Interval.of(start, start.plus(duration));
                        }
                    }
                    const end = ZonedDateTime.parse(text.substring(i + 1, text.length)).toInstant();
                    return Interval.of(start, end);
                }
            }
        }
        throw new DateTimeParseException(&apos;Interval cannot be parsed, no forward slash found&apos;, text, 0);
    }
    //-----------------------------------------------------------------------
    /**
     * Constructor.
     *
     * @param {Instant} startInclusive  the start instant, inclusive, validated not null
     * @param {Instant} endExclusive  the end instant, exclusive, validated not null
     */
    constructor(startInclusive, endExclusive) {
        this._start = startInclusive;
        this._end = endExclusive;
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the start of this time interval, inclusive.
     * &lt;p&gt;
     * This will return {@link Instant#MIN} if the range is unbounded at the start.
     * In this case, the range includes all dates into the far-past.
     *
     * @return {Instant} the start of the time interval
     */
    start() {
        return this._start;
    }

    /**
     * Gets the end of this time interval, exclusive.
     * &lt;p&gt;
     * This will return {@link Instant#MAX} if the range is unbounded at the end.
     * In this case, the range includes all dates into the far-future.
     *
     * @return {Instant} the end of the time interval, exclusive
     */
    end() {
        return this._end;
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if the range is empty.
     * &lt;p&gt;
     * An empty range occurs when the start date equals the inclusive end date.
     *
     * @return {boolean} true if the range is empty
     */
    isEmpty() {
        return this._start.equals(this._end);
    }

    /**
     * Checks if the start of the interval is unbounded.
     *
     * @return {boolean} true if start is unbounded
     */
    isUnboundedStart() {
        return this._start.equals(Instant.MIN);
    }

    /**
     * Checks if the end of the interval is unbounded.
     *
     * @return {boolean} true if end is unbounded
     */
    isUnboundedEnd() {
        return this._end.equals(Instant.MAX);
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this range with the specified start instant.
     *
     * @param {Instant} start  the start instant for the new interval, not null
     * @return {Interval} an interval with the end from this interval and the specified start
     * @throws DateTimeException if the resulting interval has end before start
     */
    withStart(start) {
        return Interval.of(start, this._end);
    }

    /**
     * Returns a copy of this range with the specified end instant.
     *
     * @param {Instant} end  the end instant for the new interval, not null
     * @return {Interval} an interval with the start from this interval and the specified end
     * @throws DateTimeException if the resulting interval has end before start
     */
    withEnd(end) {
        return Interval.of(this._start, end);
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if this interval contains the specified instant.
     * &lt;p&gt;
     * This checks if the specified instant is within the bounds of this interval.
     * If this range has an unbounded start then {@code contains(Instant#MIN)} returns true.
     * If this range has an unbounded end then {@code contains(Instant#MAX)} returns true.
     * If this range is empty then this method always returns false.
     *
     * @param {Instant} instant  the instant, not null
     * @return {boolean} true if this interval contains the instant
     */
    contains(instant) {
        requireNonNull(instant, &apos;instant&apos;);
        requireInstance(instant, Instant, &apos;instant&apos;);
        return this._start.compareTo(instant) &lt;= 0 &amp;&amp; (instant.compareTo(this._end) &lt; 0 || this.isUnboundedEnd());
    }

    /**
     * Checks if this interval encloses the specified interval.
     * &lt;p&gt;
     * This checks if the bounds of the specified interval are within the bounds of this interval.
     * An empty interval encloses itself.
     *
     * @param {Interval} other  the other interval, not null
     * @return {boolean} true if this interval contains the other interval
     */
    encloses(other) {
        requireNonNull(other, &apos;other&apos;);
        requireInstance(other, Interval, &apos;other&apos;);
        return this._start.compareTo(other.start()) &lt;= 0 &amp;&amp; other.end().compareTo(this._end) &lt;= 0;
    }

    /**
     * Checks if this interval abuts the specified interval.
     * &lt;p&gt;
     * The result is true if the end of this interval is the start of the other, or vice versa.
     * An empty interval does not abut itself.
     *
     * @param {Interval} other  the other interval, not null
     * @return {boolean} true if this interval abuts the other interval
     */
    abuts(other) {
        requireNonNull(other, &apos;other&apos;);
        requireInstance(other, Interval, &apos;other&apos;);
        return !this._end.equals(other.start()) !== !this._start.equals(other.end());
    }

    /**
     * Checks if this interval is connected to the specified interval.
     * &lt;p&gt;
     * The result is true if the two intervals have an enclosed interval in common, even if that interval is empty.
     * An empty interval is connected to itself.
     * &lt;p&gt;
     * This is equivalent to {@code (overlaps(other) || abuts(other))}.
     *
     * @param {Interval} other  the other interval, not null
     * @return {boolean} true if this interval is connected to the other interval
     */
    isConnected(other) {
        requireNonNull(other, &apos;other&apos;);
        requireInstance(other, Interval, &apos;other&apos;);
        return this.equals(other) || (this._start.compareTo(other.end()) &lt;= 0 &amp;&amp; other.start().compareTo(this._end) &lt;= 0);
    }

    /**
     * Checks if this interval overlaps the specified interval.
     * &lt;p&gt;
     * The result is true if the the two intervals share some part of the time-line.
     * An empty interval overlaps itself.
     * &lt;p&gt;
     * This is equivalent to {@code (isConnected(other) &amp;&amp; !abuts(other))}.
     *
     * @param {Interval} other  the time interval to compare to, null means a zero length interval now
     * @return {boolean} true if the time intervals overlap
     */
    overlaps(other) {
        requireNonNull(other, &apos;other&apos;);
        requireInstance(other, Interval, &apos;other&apos;);
        return other.equals(this) || (this._start.compareTo(other.end()) &lt; 0 &amp;&amp; other.start().compareTo(this._end) &lt; 0);
    }

    //-----------------------------------------------------------------------
    /**
     * Calculates the interval that is the intersection of this interval and the specified interval.
     * &lt;p&gt;
     * This finds the intersection of two intervals.
     * This throws an exception if the two intervals are not {@linkplain #isConnected(Interval) connected}.
     *
     * @param {Interval} other  the other interval to check for, not null
     * @return {Interval} the interval that is the intersection of the two intervals
     * @throws DateTimeException if the intervals do not connect
     */
    intersection(other) {
        requireNonNull(other, &apos;other&apos;);
        requireInstance(other, Interval, &apos;other&apos;);
        if (this.isConnected(other) === false) {
            throw new DateTimeException(`Intervals do not connect: ${this} and ${other}`);
        }
        const cmpStart = this._start.compareTo(other.start());
        const cmpEnd = this._end.compareTo(other.end());
        if (cmpStart &gt;= 0 &amp;&amp; cmpEnd &lt;= 0) {
            return this;
        } else if (cmpStart &lt;= 0 &amp;&amp; cmpEnd &gt;= 0) {
            return other;
        } else {
            const newStart = (cmpStart &gt;= 0 ? this._start : other.start());
            const newEnd = (cmpEnd &lt;= 0 ? this._end : other.end());
            return Interval.of(newStart, newEnd);
        }
    }

    /**
     * Calculates the interval that is the union of this interval and the specified interval.
     * &lt;p&gt;
     * This finds the union of two intervals.
     * This throws an exception if the two intervals are not {@linkplain #isConnected(Interval) connected}.
     *
     * @param {Interval} other  the other interval to check for, not null
     * @return {Interval} the interval that is the union of the two intervals
     * @throws DateTimeException if the intervals do not connect
     */
    union(other) {
        requireNonNull(other, &apos;other&apos;);
        requireInstance(other, Interval, &apos;other&apos;);
        if (this.isConnected(other) === false) {
            throw new DateTimeException(`Intervals do not connect: ${this} and ${other}`);
        }
        const cmpStart = this._start.compareTo(other.start());
        const cmpEnd = this._end.compareTo(other.end());
        if (cmpStart &gt;= 0 &amp;&amp; cmpEnd &lt;= 0) {
            return other;
        } else if (cmpStart &lt;= 0 &amp;&amp; cmpEnd &gt;= 0) {
            return this;
        } else {
            const newStart = (cmpStart &gt;= 0 ? other.start() : this._start);
            const newEnd = (cmpEnd &lt;= 0 ? other.end() : this._end);
            return Interval.of(newStart, newEnd);
        }
    }

    /**
     * Calculates the smallest interval that encloses this interval and the specified interval.
     * &lt;p&gt;
     * The result of this method will {@linkplain #encloses(Interval) enclose}
     * this interval and the specified interval.
     *
     * @param {Interval} other  the other interval to check for, not null
     * @return {Interval} the interval that spans the two intervals
     */
    span(other) {
        requireNonNull(other, &apos;other&apos;);
        requireInstance(other, Interval, &apos;other&apos;);
        const cmpStart = this._start.compareTo(other.start());
        const cmpEnd = this._end.compareTo(other.end());
        const newStart = (cmpStart &gt;= 0 ? other.start() : this._start);
        const newEnd = (cmpEnd &lt;= 0 ? other.end() : this._end);
        return Interval.of(newStart, newEnd);
    }

    //-------------------------------------------------------------------------
    /**
     * function overloading for {@link Interval#isAfter}
     *
     * if called with an Instant, then {@link Interval#isAfterInstant} is executed.
     *
     * Otherwise {@link Interval#isAfterInterval} is executed.
     *
     * @param {!(Instant|Interval)} instantOrInterval
     * @returns {boolean}
     */
    isAfter(instantOrInterval) {
        if (instantOrInterval instanceof Instant) {
            return this.isAfterInstant(instantOrInterval);
        } else {
            return this.isAfterInterval(instantOrInterval);
        }
    }

    /**
     * function overloading for {@link Interval#isBefore}
     *
     * if called with an Instant, then {@link Interval#isBeforeInstant} is executed.
     *
     * Otherwise {@link Interval#isBeforeInterval} is executed.
     *
     * @param {!(Instant|Interval)} instantOrInterval
     * @returns {boolean}
     */
    isBefore(instantOrInterval) {
        if (instantOrInterval instanceof Instant) {
            return this.isBeforeInstant(instantOrInterval);
        } else {
            return this.isBeforeInterval(instantOrInterval);
        }
    }

    /**
     * Checks if this interval is after the specified instant.
     * &lt;p&gt;
     * The result is true if the this instant starts after the specified instant.
     * An empty interval behaves as though it is an instant for comparison purposes.
     *
     * @param {Instant} instant  the other instant to compare to, not null
     * @return {boolean} true if the start of this interval is after the specified instant
     */
    isAfterInstant(instant) {
        return this._start.compareTo(instant) &gt; 0;
    }

    /**
     * Checks if this interval is before the specified instant.
     * &lt;p&gt;
     * The result is true if the this instant ends before the specified instant.
     * Since intervals do not include their end points, this will return true if the
     * instant equals the end of the interval.
     * An empty interval behaves as though it is an instant for comparison purposes.
     *
     * @param {Instant} instant  the other instant to compare to, not null
     * @return {boolean} true if the start of this interval is before the specified instant
     */
    isBeforeInstant(instant) {
        return this._end.compareTo(instant) &lt;= 0 &amp;&amp; this._start.compareTo(instant) &lt; 0;
    }

    //-------------------------------------------------------------------------
    /**
     * Checks if this interval is after the specified interval.
     * &lt;p&gt;
     * The result is true if the this instant starts after the end of the specified interval.
     * Since intervals do not include their end points, this will return true if the
     * instant equals the end of the interval.
     * An empty interval behaves as though it is an instant for comparison purposes.
     *
     * @param {Interval} interval  the other interval to compare to, not null
     * @return {boolean} true if this instant is after the specified instant
     */
    isAfterInterval(interval) {
        return this._start.compareTo(interval.end()) &gt;= 0 &amp;&amp; !interval.equals(this);
    }

    /**
     * Checks if this interval is before the specified interval.
     * &lt;p&gt;
     * The result is true if the this instant ends before the start of the specified interval.
     * Since intervals do not include their end points, this will return true if the
     * two intervals abut.
     * An empty interval behaves as though it is an instant for comparison purposes.
     *
     * @param {Interval} interval  the other interval to compare to, not null
     * @return {boolean} true if this instant is before the specified instant
     */
    isBeforeInterval(interval) {
        return this._end.compareTo(interval.start()) &lt;= 0 &amp;&amp; !interval.equals(this);
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains the duration of this interval.
     * &lt;p&gt;
     * An {@code Interval} is associated with two specific instants on the time-line.
     * A {@code Duration} is simply an amount of time, separate from the time-line.
     *
     * @return {Duration} the duration of the time interval
     * @throws ArithmeticException if the calculation exceeds the capacity of {@code Duration}
     */
    toDuration() {
        return Duration.between(this._start, this._end);
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if this interval is equal to another interval.
     * &lt;p&gt;
     * Compares this {@code Interval} with another ensuring that the two instants are the same.
     * Only objects of type {@code Interval} are compared, other types return false.
     *
     * @param {*} obj  the object to check, null returns false
     * @return {boolean} true if this is equal to the other interval
     */
    equals(obj) {
        if (this === obj) {
            return true;
        }
        if (obj instanceof Interval) {
            return this._start.equals(obj.start()) &amp;&amp; this._end.equals(obj.end());
        }
        return false;
    }

    /**
     * A hash code for this interval.
     *
     * @return {number} a suitable hash code
     */
    hashCode() {
        // eslint-disable-next-line no-bitwise
        return this._start.hashCode() ^ this._end.hashCode();
    }

    //-----------------------------------------------------------------------
    /**
     * Outputs this interval as a {@code String}, such as {@code 2007-12-03T10:15:30/2007-12-04T10:15:30}.
     * &lt;p&gt;
     * The output will be the ISO-8601 format formed by combining the
     * {@code toString()} methods of the two instants, separated by a forward slash.
     *
     * @return {string} a string representation of this instant, not null
     */
    toString() {
        return `${this._start.toString()}/${this._end.toString()}`;
    }
}

export function _init() {
    Interval.ALL = Interval.of(Instant.MIN, Instant.MAX);
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
